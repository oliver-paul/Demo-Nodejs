pipeline {
    agent any
    
    environment {
        // Docker image configuration
        DOCKER_IMAGE_NAME = 'node-project'
        DOCKER_IMAGE_TAG = "${BUILD_NUMBER}"
        DOCKER_IMAGE_LATEST = "${DOCKER_IMAGE_NAME}:latest"
        DOCKER_IMAGE_VERSIONED = "${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG}"
        
        // ArgoCD configuration
        ARGOCD_SERVER = 'argocd-server:8080'
        ARGOCD_APP_NAME = 'node-project-app'
        ARGOCD_NAMESPACE = 'node-project'
        
        // Paths
        WORKSPACE_PATH = '/workspace'
        DEPLOY_PATH = '/workspace/deploy'
    }
    
    stages {
        stage('Checkout') {
            steps {
                echo 'Checking out code...'
                script {
                    // Code is already mounted in Jenkins container
                    sh 'ls -la ${WORKSPACE_PATH}'
                }
            }
        }
        
        stage('Install Dependencies') {
            steps {
                echo 'Installing Node.js dependencies...'
                dir("${WORKSPACE_PATH}") {
                    sh '''
                        if [ -f package.json ]; then
                            echo "package.json found"
                            cat package.json
                        fi
                    '''
                }
            }
        }
        
        stage('Run Tests') {
            steps {
                echo 'Running tests...'
                dir("${WORKSPACE_PATH}") {
                    sh '''
                        # Install Docker in Jenkins if not present
                        if ! command -v docker &> /dev/null; then
                            echo "Installing Docker..."
                            apt-get update
                            apt-get install -y docker.io
                        fi
                        
                        echo "Tests would run here"
                        # npm test --passWithNoTests || true
                    '''
                }
            }
        }
        
        stage('Build Docker Image') {
            steps {
                echo "Building Docker image: ${DOCKER_IMAGE_VERSIONED}"
                dir("${WORKSPACE_PATH}") {
                    sh '''
                        # Build Docker image with version tag
                        docker build -t ${DOCKER_IMAGE_VERSIONED} .
                        
                        # Tag as latest
                        docker tag ${DOCKER_IMAGE_VERSIONED} ${DOCKER_IMAGE_LATEST}
                        
                        # List images
                        docker images | grep ${DOCKER_IMAGE_NAME}
                    '''
                }
            }
        }
        
        stage('Push to Local Registry') {
            steps {
                echo 'Docker image built locally and available for Kubernetes'
                sh '''
                    echo "Image ${DOCKER_IMAGE_VERSIONED} is ready"
                    echo "Image ${DOCKER_IMAGE_LATEST} is ready"
                    
                    # If you have a local registry, push here:
                    # docker tag ${DOCKER_IMAGE_VERSIONED} localhost:5000/${DOCKER_IMAGE_VERSIONED}
                    # docker push localhost:5000/${DOCKER_IMAGE_VERSIONED}
                '''
            }
        }
        
        stage('Update Kubernetes Manifests') {
            steps {
                echo 'Updating Kubernetes deployment manifests...'
                dir("${WORKSPACE_PATH}") {
                    sh '''
                        # Update the image tag in deployment.yaml
                        if [ -f ${DEPLOY_PATH}/deployment.yaml ]; then
                            echo "Updating deployment.yaml with new image tag..."
                            
                            # Backup original
                            cp ${DEPLOY_PATH}/deployment.yaml ${DEPLOY_PATH}/deployment.yaml.bak
                            
                            # Update image tag (using sed)
                            sed -i "s|image: ${DOCKER_IMAGE_NAME}:.*|image: ${DOCKER_IMAGE_VERSIONED}|g" ${DEPLOY_PATH}/deployment.yaml
                            
                            echo "Updated deployment.yaml:"
                            grep "image:" ${DEPLOY_PATH}/deployment.yaml
                        else
                            echo "deployment.yaml not found!"
                            exit 1
                        fi
                    '''
                }
            }
        }
        
        stage('Verify Manifests') {
            steps {
                echo 'Verifying Kubernetes manifests...'
                sh '''
                    echo "Checking manifest files..."
                    ls -la ${DEPLOY_PATH}/
                    
                    echo "\\nDeployment manifest:"
                    cat ${DEPLOY_PATH}/deployment.yaml | grep -A 5 "image:"
                '''
            }
        }
        
        stage('Install ArgoCD CLI') {
            steps {
                echo 'Installing ArgoCD CLI...'
                sh '''
                    # Check if argocd CLI is installed
                    if ! command -v argocd &> /dev/null; then
                        echo "Installing ArgoCD CLI..."
                        curl -sSL -o /usr/local/bin/argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
                        chmod +x /usr/local/bin/argocd
                    fi
                    
                    argocd version --client || true
                '''
            }
        }
        
        stage('Login to ArgoCD') {
            steps {
                echo 'Logging into ArgoCD...'
                sh '''
                    # Wait for ArgoCD server to be ready
                    echo "Waiting for ArgoCD server..."
                    sleep 10
                    
                    # Login to ArgoCD (using default credentials)
                    # Default username: admin
                    # Get initial password from argocd-server pod
                    
                    argocd login ${ARGOCD_SERVER} \\
                        --username admin \\
                        --password admin \\
                        --insecure || echo "Login failed, ArgoCD might not be fully initialized"
                '''
            }
        }
        
        stage('Create/Update ArgoCD Application') {
            steps {
                echo 'Creating or updating ArgoCD application...'
                sh '''
                    # Check if application exists
                    if argocd app get ${ARGOCD_APP_NAME} --server ${ARGOCD_SERVER} --insecure 2>/dev/null; then
                        echo "Application ${ARGOCD_APP_NAME} already exists"
                    else
                        echo "Creating ArgoCD application..."
                        argocd app create ${ARGOCD_APP_NAME} \\
                            --repo file://${WORKSPACE_PATH} \\
                            --path deploy \\
                            --dest-server https://kubernetes.default.svc \\
                            --dest-namespace ${ARGOCD_NAMESPACE} \\
                            --server ${ARGOCD_SERVER} \\
                            --insecure || echo "App creation skipped"
                    fi
                '''
            }
        }
        
        stage('Sync with ArgoCD') {
            steps {
                echo 'Syncing application with ArgoCD...'
                sh '''
                    echo "Syncing ${ARGOCD_APP_NAME} with Kubernetes cluster..."
                    
                    # Sync the application
                    argocd app sync ${ARGOCD_APP_NAME} \\
                        --server ${ARGOCD_SERVER} \\
                        --insecure \\
                        --force || echo "Sync command executed"
                    
                    # Wait for sync to complete
                    argocd app wait ${ARGOCD_APP_NAME} \\
                        --server ${ARGOCD_SERVER} \\
                        --insecure \\
                        --timeout 300 || echo "Waiting for sync..."
                '''
            }
        }
        
        stage('Verify Deployment') {
            steps {
                echo 'Verifying deployment status...'
                sh '''
                    # Get application status
                    argocd app get ${ARGOCD_APP_NAME} \\
                        --server ${ARGOCD_SERVER} \\
                        --insecure || echo "Status check completed"
                    
                    echo "\\n==================================="
                    echo "Deployment Summary:"
                    echo "==================================="
                    echo "Docker Image: ${DOCKER_IMAGE_VERSIONED}"
                    echo "ArgoCD App: ${ARGOCD_APP_NAME}"
                    echo "Namespace: ${ARGOCD_NAMESPACE}"
                    echo "Build Number: ${BUILD_NUMBER}"
                    echo "==================================="
                '''
            }
        }
    }
    
    post {
        success {
            echo 'Pipeline completed successfully!'
            echo "Application deployed with image: ${DOCKER_IMAGE_VERSIONED}"
        }
        failure {
            echo 'Pipeline failed!'
            sh '''
                echo "Checking logs..."
                docker ps -a
            '''
        }
        always {
            echo 'Cleaning up...'
            sh '''
                # Clean up old Docker images (keep last 5)
                docker images ${DOCKER_IMAGE_NAME} --format "{{.Tag}}" | tail -n +6 | xargs -r -I {} docker rmi ${DOCKER_IMAGE_NAME}:{} || true
                
                echo "Pipeline finished at $(date)"
            '''
        }
    }
}

